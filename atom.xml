<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[mingbo]]></title>
  <link href="http://mingbo.de/atom.xml" rel="self"/>
  <link href="http://mingbo.de/"/>
  <updated>2013-11-08T15:17:08+08:00</updated>
  <id>http://mingbo.de/</id>
  <author>
    <name><![CDATA[shaomingbo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[视图的绘制]]></title>
    <link href="http://mingbo.de/blog/2013/11/08/how-android-draws-views/"/>
    <updated>2013-11-08T14:48:00+08:00</updated>
    <id>http://mingbo.de/blog/2013/11/08/how-android-draws-views</id>
    <content type="html"><![CDATA[<p>在<a href="http://mingbo.de/blog/2013/11/04/listview-re-getview/">《Listview 子控件重复加载》</a>中谈到了<code>onMeasure()</code>方法，谈到了layout，但更细致的内容没有提到。这里找了一下相关资料来补充：</p>

<ul>
<li>绘制过程是一个控件树遍历的过程，从根控件开始</li>
<li><code>ViewGroup</code>负责通知它的子视图，<code>View</code>负责自绘，按照顺序，父视图先于子视图绘制</li>
<li>绘制实际上是2个自顶向下的过程：measure 和layout。</li>
<li>经过measure 之后，每个<code>View</code>都会保存自己的尺寸，而在layout 过程中父视图会使用这些尺寸来摆放子视图</li>
<li><code>View</code>对象的高宽会受到父视图的限制，以保证整个视图的正常显示</li>
<li>父视图会<strong>多次调用子视图的measure方法</strong>。比如：父视图会先计算不受约束的情况下，子视图的大小；如果子视图过大或者过小，父视图都会指定一个具体的值</li>
<li>Measure 过程还会涉及<code>ViewGroup.LayoutParams</code>以及<code>MeasureSpec</code>的设置</li>
<li><code>ViewGroup.LayoutParams</code>被View 对象用来告诉其父控件，自己想如何被计算以及摆放，最基本的是指定长宽：

<ol>
<li>MATCH_PARENT, which means the View wants to be as big as its parent (minus padding)</li>
<li>WRAP_CONTENT, which means that the View wants to be just big enough to enclose its content (plus padding).</li>
<li>具体数值</li>
</ol>
</li>
<li>MeasureSpec 指定一种计算模式：

<ol>
<li>UNSPECIFIED: This is used by a parent to determine the desired dimension of a child View.</li>
<li>EXACTLY: This is used by the parent to impose an exact size on the child.</li>
<li>AT MOST: This is used by the parent to impose a maximum size on the child.</li>
</ol>
</li>
</ul>


<h3>参考资料</h3>

<ul>
<li><a href="https://developer.android.com/guide/topics/ui/how-android-draws.html">How Android Draws Views</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Listview 子控件重复加载]]></title>
    <link href="http://mingbo.de/blog/2013/11/04/listview-re-getview/"/>
    <updated>2013-11-04T20:45:00+08:00</updated>
    <id>http://mingbo.de/blog/2013/11/04/listview-re-getview</id>
    <content type="html"><![CDATA[<p>这是一个常见的listview 资源文件的写法。</p>

<figure class='code'><figcaption><span>listview资源文件 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;ListView</span>
</span><span class='line'>        <span class="na">android:layout_width=</span><span class="s">&quot;match_parent&quot;</span>
</span><span class='line'>        <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>        <span class="na">android:id=</span><span class="s">&quot;@+id/listView&quot;</span>
</span><span class='line'>    <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意到<code>android:layout_height</code> 被设置为<code>wrap_content</code>，这似乎很合理。但如果我们留心的话可以发现，与这个listview 关联的adapter对象的<code>getView()</code>方法被<strong>重复调用了好几遍</strong>!这对于那些依赖listview 展示大量数据的应用来说，绝对是性能打击。</p>

<h3>解决方案：</h3>

<p>将这个属性设置为<code>match_parent</code> 或者固定的数值</p>

<h3>原因：</h3>

<p>通过分析<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/AbsListView.java">AbsListView</a> 以及<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ListView.java">Listview</a>的代码，发现答案应该在<code>onMeasure()</code>方法里：由于<code>wrap_content</code> 并没有指定一个固定值，<strong>系统需要通过尝试layout来满足<code>wrap_content</code></strong>。每次尝试都会调用<code>onMeasure()</code>,<code>layoutChildren()</code>,使得<code>getView()</code>被重复调用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service 心经]]></title>
    <link href="http://mingbo.de/blog/2013/11/04/services-note/"/>
    <updated>2013-11-04T15:21:00+08:00</updated>
    <id>http://mingbo.de/blog/2013/11/04/services-note</id>
    <content type="html"><![CDATA[<p>Service 作为一个“看不见”的android 组件，天然的就应该为Android 程序去处理那些费事费力的苦活。但即使这样，作为四大组件之一的它依然运行在主线程上。也就是说，那些理所当然的“负担”如果<strong>直接运行在Service 上必然会影响程序的UI 性能</strong>。因此，我们通常需要与之对应的后台线程来完成工作。</p>

<p>与其他组件一样，要想Service 正常运行，就必须在<code>AndroidManifest.xml</code> 中对其进行声明。如果Service 作为一个开放组件（允许外部程序调用），则还需要设置Intent Filter 来支持隐式调用；反之，如果它只在程序内运行，则可省去Filter 设置，更妥当的做法是将<code>export</code>属性设置为false。</p>

<p>总的来说，Service 有两种形式：<strong>命令启动类(Started)</strong> 与 <strong>绑定类(Bound)</strong>。两种形式之间并不总是非此既彼的关系，同一个应用的同一个Service 可以同时满足这两种形式，而这一点完全取决于应用逻辑。</p>

<h3>命令启动类（started）的Service</h3>

<ul>
<li>一旦被启动，如果没有其他组件调用<code>stopService()</code>而且自己也没有调用<code>stopSelf(int)</code>，那么它将会一直运行下去（除非系统内存吃紧）</li>
<li><code>onStartCommand()</code>有三类返回值，分别代表Service 在执行完该函数之后，如遭遇系统Kill 的不同策略：

<ol>
<li><code>START_NOT_STICKY</code>，除非有新的命令，不然不会重新构建Service</li>
<li><code>START_STICKY</code>，不死Service。如果系统资源允许，会重新构建Service并调用<code>startCommand()</code>，但并不会重新传递最后一次发过来的intent。（适用于不care 命令，而care 启没启动的操作，比如恢复音乐播放）</li>
<li><code>START_REDELIVER_INTENT</code>, 对intent 负责到底。在系统资源允许的情况下，重新构建service并将最后一次发送的intent 通过参数传递给<code>startCommand()</code>。（适用于care 命令，比如恢复下载某个文件）</li>
</ol>
</li>
<li>和绑定类服务不同，如果希望得到交互结果，则必须使用Broardcast传递</li>
<li><code>startCommand()</code> 会有并发的情况，但<code>stopService()</code> 只会执行一次。所以在具体应用场景中，我们需要考虑命令Service们能不能、该不该被中途停止。如果得到的答案是否定的，那么我们应该尝试使用<code>stopSelf(int)</code>来管理service，其参数为希望停止的service ID。</li>
</ul>


<h3>简化的命令服务IntentServie</h3>

<p>如果你不希望Service 处理并发请求，那么IntentService 是不二的选择。之所以这么说，是你几乎只需要三步就可以实现一个为你完成后台操作的单线程服务：1，继承IntetnService；2，覆盖<code>onHandleIntent()</code>；3，在构造函数中初始化父类。那么IntentService 会帮你做到：
&ndash;   创建一个后台线程
&ndash;   创建一个消息队列来执行任务
&ndash;   当没有任务的时候自动停止</p>

<p>如果希望自己覆盖某些Service 的方法，<strong>那么一定要记得调用super</strong>，否则会导致一些意想不到的结果出现。</p>

<h3>绑定类(Bound)服务</h3>

<ul>
<li><code>IBinder</code> 表示客户端与服务端交互的接口</li>
<li>三种提供Binder 接口的方法：

<ol>
<li>直接继承Binder 类，提供API 给客户端调用。这些API 既可以由Binder 子类来实现，也可以通过API 返回该服务或其他服务的实例，由服务本身提供的方法去完成调用；<strong>这种方法适用与私有服务</strong>。</li>
<li>使用Messenger返回binder。该方法的本质是AIDL，提供了一种线程安全的跨进程通讯方案。<strong>这种方法适用于服务与调用组件不在同一个进程的情况</strong>。详见<code>参考代码</code></li>
<li>如果服务不但跨进程，而且还希望处理并发请求，则应该使用<code>AIDL</code>来实现</li>
</ol>
</li>
<li>多个客户端可以绑定同一个服务，但<code>onBind()</code> 只会在第一个客户端绑定的时候被调用。之后绑定的客户端虽然会获得同样的binder，但已经不会再调用<code>onBind()</code>了</li>
<li>四大组件中除了<code>Broardcast Receiver</code>之外都可以绑定服务</li>
<li><code>onServiceDisconnected()</code>只会在服务崩溃的时候调用，<strong>而并不会在unbind 的时候被调用</strong></li>
<li>bind 应与unbind 成对出现，服务与其绑定的客户端组件共存亡。如果交互工作完全结束的话，可以尽早的结束绑定，而不一定要等到组件消亡(比如某浪sso 接口那样)</li>
<li>bind 与unbind 不应该出现在<code>onResume()</code> 以及<code>onPause()</code>里，这样会使得服务的绑定与解绑操作过于频繁</li>
<li>绑定类服务又恰巧被调用了<code>startService()</code>，则只有同时满足以下条件，服务才会终止：1，没有客户端组件绑定该服务；2，服务调用了<code>stopService()</code> 或者<code>stopSelf(int)</code></li>
<li>如下图所示，只有当<code>unBind()</code>返回true 的时候，下次绑定的时候，系统才会调用<code>onRebind()</code>，否则还会继续调用<code>onBind()</code></li>
<li>所有对象均为跨进程引用计数</li>
<li>如果服务连接丢失的话，容易引发<code>DeadObjectException</code></li>
</ul>


<p><img src="https://developer.android.com/images/fundamentals/service_binding_tree_lifecycle.png" alt="服务的生命周期" /></p>

<h3>前台服务</h3>

<ul>
<li>前台服务能够极大的提升不被杀掉的概率</li>
<li>前台服务必须有与之对应<strong>ON-GONING</strong>通知显示</li>
<li><code>stopForeground()</code>并不会停止服务；而停止服务后，通知自然消亡</li>
</ul>


<h3>AIDL</h3>

<ul>
<li>Stub 继承自Binder 还实现了aidl 中的接口，除此之外还提供类似<code>asInterface(IBinder)</code>的辅助方法</li>
<li>AIDL 接口调用是直接方法调用，不应该想当然的认为它们在哪个线程中执行。如果是本地进程调用，那么接口会和调用者使用同一个线程执行；如果是远程调用，会由服务所在的进程的线程池派发一个线程来执行；如果使用oneway修饰，在远程调用中是非阻塞的，而在本地调用中依然是同步的。</li>
<li>AIDL 支持java 的基础类型、<code>String</code>、<code>Charsequence</code>、<code>List</code>、<code>Map</code>，除此之外的类型，都需要实现Parcebal接口，且必须使用import来声明，即使它们在同一个包</li>
<li>调用不保证会执行，所以从一开始设计的时候就应该考虑线程安全</li>
<li>为了避免ANR，应该将调用转移到单独的线程中执行</li>
<li>抛出的异常不会被调用者捕获（跨进程异常是不可取的）</li>
</ul>


<h3>参考资料</h3>

<ul>
<li><a href="https://developer.android.com/guide/components/services.html">Services</a></li>
<li><a href="https://developer.android.com/guide/components/bound-services.html">Bound Services</a></li>
<li><a href="https://developer.android.com/guide/components/aidl.html">AIDL</a></li>
</ul>


<h3>参考代码</h3>

<ul>
<li><a href="https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/LocalService.java">LocalService.java</a></li>
<li><a href="https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/LocalServiceActivities.java">LocalServiceActivities.java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity 心经]]></title>
    <link href="http://mingbo.de/blog/2013/11/03/activity-note/"/>
    <updated>2013-11-03T11:33:00+08:00</updated>
    <id>http://mingbo.de/blog/2013/11/03/activity-note</id>
    <content type="html"><![CDATA[<p>Android 四大组件中，Activty 最为常见。这里对Activity 的相关知识进行梳理，以供日后查阅。</p>

<h3>生命周期</h3>

<p><img src="https://developer.android.com/images/training/basics/basic-lifecycle.png" alt="生命周期" /></p>

<ul>
<li>六种状态构成了生命周期金字塔</li>
<li>位于顶端的Resumed 状态有着与用户交互的特权</li>
<li>金字塔的第二层对于用户来说可视或部分可视</li>
<li>金字塔的第三层虽然存在于系统内存，但对于用户来说不可视</li>
<li>从箭头的指向来看，<strong>Resumed 与Paused 之间的转换最为活跃</strong>，为了保证UI流畅，这里应尽可能的放一些轻巧的代码</li>
<li>从Activity 对象的角度来讲，只有<strong>三种状态持续存在</strong>：Resumed，Paused，Stopped</li>
<li>Activity 的Paused 状态对于自身而言是被前台的Activity(或窗口）遮挡了一部分，对于用户来讲这个Activity 只有部分可见。<strong>在这种状态下，Activity 对象依然停留在内存里，也同时被windows manager 引用着</strong>；Activity 的Stopped状态与Paused 状态类似，<strong>除了</strong>更彻底的不可见<strong>之外</strong>，此时此刻这个Activity已经不被windows manager 引用了</li>
<li>当Activity 的Paused 或Stopped状态遭遇系统内存吃紧：系统要么温柔的调用<code>finish()</code> 逐个清理Activity，要么粗暴的结束掉该对象所在的进程</li>
</ul>


<h3>资源管理</h3>

<ul>
<li>鉴于<strong>内存吃紧</strong>的不可预见，我们应该在<code>onStop()</code>中释放掉那些容易造成内存泄漏的资源</li>
<li>关于<code>onPause()</code>方法更具体的建议

<pre><code>1.  停止动画等消耗CPU 的操作
2.  注销广播监听器、传感器监听器等影响电池寿命的资源
3.  仅当用户需要的情况下，提交未保存的状态。为了保证界面的平滑切换，应避免在这里调用CPU-Intensive 的操作（如，写数据库），而应将其移至之后的stop方法中
</code></pre></li>
<li> <code>onSaveInstanceState()</code>默认的会保存Activity 的视图结构，如Checkbox 是否被选中，Edittext 中的编辑文字，但前提是为每个控件都配备有一个独特的ID</li>
<li> 当且仅当有数据需要恢复的时候，<code>onRestoreInstanceState()</code>才被系统调用，且一般在<code>onStart()</code>之后</li>
<li> 可以使用<code>finish()</code>以及<code>finishActivity(int requestCode)</code>来关闭Activity，但除非你确定必须这么做，<strong>不然最好将这项工作交由系统来完成</strong></li>
<li> 一般情况下，如果一个应用退到后台超过30分钟，系统会清理掉该堆栈中的acitivties。但如果<code>android:alwaysRetainTaskState</code>属性被设置为true，用户重返应用的时候总会获得上次Activity的状态。这一点对于浏览器应用相当有用</li>
<li> 如果属性<code>android:noHistory</code>被设置为true，那么当用户从这个activity 离开的时候，就会自动调用<code>finish()</code>。因此，无法从任务堆栈中找回该activity 的历史轨迹了</li>
<li> 一般来讲，<code>onDestroy()</code> 的执行应该在<code>onPause()</code>或者<code>onStop()</code>之后。但如果，你在<code>onCreate()</code>中直接调用<code>finish()</code>，则系统会直接跳过他们调用<code>onDestroy()</code>的</li>
</ul>


<h3>运行模式</h3>

<ul>
<li>Task 是由一组为了完成某项工作的Activities 组成，它们<strong>不受</strong>进程或应用的约束，体现的是Activity 之间<strong>相互调用和执行</strong>的关系</li>
<li>Activity 的运行模式有四种:standard，singleTop，singleTask，singleInstance。除了Standard 之外的三种模式对于activity均有不同程度的复用</li>
<li>standard 与singleTop 类似，在程序运行的过程中，这两种模式的activity 会有多个实例出现在一个或多个Task 中的任意位置。但二者之间有着细微的差别：singleTop 模式下的activty 如果在目标task 的顶部，对于新收到的intent会使用<code>onNewIntent()</code>回调来响应；其他情况下和standard 模式一样，对于每一个新收到的intent 都对应一个新的实例。</li>
<li>singleTask 与singleInstance 类似，都只能出现在一个task stack 内，且始终呆在stack 的根部，对于整个设备来说它们只有一个实例。除此之外，它们都使用<code>onNewIntent()</code> 来响应创建后收到的intent。但两者之间有着细微的差别：singleTask 允许引入新的activity 来组建task，而singleInstance 永远自成一派。很显然，singleInstance适合内存消耗较多的界面，如播放器、浏览器等。</li>
</ul>


<h3>其他</h3>

<ul>
<li>如果项目中没有一个Activity 被设置为<code>MAIN action</code> 或者<code>LAUNCHER category</code>，那么桌面就不会显示相应的图标</li>
<li>程序运行过程中，如遇到配置变动，则会引起activity 重启，这是系统自动适配的行为。</li>
<li>重启后，其数据需要得到重新填充。如果数据量较小，则可以依赖<code>onSaveInstanceState()</code>以及<code>onRestoreInstanceState()</code>这两个回调接口；反之，则需要特殊对待：要么规避系统的重启行为，自己来做适配工作；要么在配置变更的时候通过接口<code>onRetainNonConfigurationInstance()</code>来保存数据对象，待到重启之后使用<code>getLastNonConfigurationInstance()</code>来恢复相关数据</li>
</ul>


<hr />

<h3>参考资料</h3>

<ul>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/starting.html">Starting an Activity</a></li>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/pausing.html">Pausing and Resuming an Activity</a></li>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/stopping.html">Stopping and Restarting an Activity</a></li>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/recreating.html">Recreating an Activity</a></li>
<li><a href="https://developer.android.com/guide/components/activities.html">Activities</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/activity-element.html">android:launchMode</a></li>
<li><a href="https://developer.android.com/guide/topics/resources/runtime-changes.html">Handling Runtime Changes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[廉价的吐槽]]></title>
    <link href="http://mingbo.de/blog/2013/04/14/comment-is-cheap/"/>
    <updated>2013-04-14T19:44:00+08:00</updated>
    <id>http://mingbo.de/blog/2013/04/14/comment-is-cheap</id>
    <content type="html"><![CDATA[<p>这几年，你有没有发现“赞美”变成了一件奢侈的事情？尤其当你面对一群挑剔的听众，你的赞美往往会被人扭曲：“你拿了人家什么好处，这样帮他说话？”、“推销？你被洗脑了吧！”、“这你都没见过？有什么好大惊小怪的。”…诸如此类。不晓得从什么时候开始，开口赞美，也变得越来越有压力了。</p>

<p>赞美的起点似乎总比被赞美的事物要低，反而吐槽更容易让你居高临下，优越感一览无遗。不管人家说什么，你跟着去赞美，容易被人说成是拍马，而吐槽的言行至少不会显得你太低端（哈哈，说这是批判精神）。这种不用思考的“安全反应”，使得越来越多的人，习惯了吐槽。当跟风赞美变成弱智、“五毛”之后，跟风吐槽就显得有节操，有品位了。任何事情，你都可以表现得不屑一顾，“安全的”凌驾于其之上。只是，这种廉价的破烂习惯，让我们的社会关系变得越来越冷漠了。</p>

<p>其实，生活中并不缺乏温情的画面，讲一个刚刚发生的故事。昨天晚上，我习惯性的去了趟沃尔玛。轮到我结账的时候，为了不让后面排队的人等太久，我手忙脚乱的把货品往买来的2个袋子里塞。收银员打断了我的动作，说：你这些速冻食品压在最底下，回家的时候肯定就烂掉了。我愣了一下，结果，她很自然的接手了剩下来的操作。只用了一个袋子，就将所有货品麻利的装了进去，还照顾到了各种货品的运输属性（易碎性、温度、空间等），合理的安排了他们在装袋时的位置。很快的，我缓过神来，没有说话，但竖起了大拇指。</p>

<p>同样是排队结账，吐槽就显得太过廉价了。你永远可以调侃中国人多，甚至责怪超市收银出口太少，但绝大多数的情况下，你都无法避免排队等候。而这种廉价的吐槽行为，只会让自己愤怒，说不定还会影响他人，人与人之间就在消费吐槽时，变得淡了下来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读《拖延心理学》]]></title>
    <link href="http://mingbo.de/blog/2013/03/13/the-note-of-procrastination/"/>
    <updated>2013-03-13T18:27:00+08:00</updated>
    <id>http://mingbo.de/blog/2013/03/13/the-note-of-procrastination</id>
    <content type="html"><![CDATA[<p>早在1年前，这本书我还只看了几页的时候，就很兴奋的将它推荐给朋友。不过很惭愧的是，直到最近两天才真正把这本书看完。合上书本，书中的故事还会时不时的击中我那弱小的心灵，除了感叹作者的神奇之外，还真心觉得应该为自己的拖延做点什么。于是，很自然的想到写点读书笔记吧。</p>

<h3>拖延怪圈</h3>

<ul>
<li>现象：每次尝到恶果之后总会告诫自己，也会在每次任务开始之前提醒自己，可是一到真正动手的时候，总会自觉不自觉的把该做的事情撂在一边。</li>
<li>根源：<strong>这是一种内心的恐惧</strong>&mdash;害怕自己的行为不合适、不被他人接受。</li>
<li>解释：人们之所以产生拖延的不良习性，是因为他们害怕。害怕如果自己行动了，而达不到预期的效果。害怕自己不被接受，以致于躲开这个世界，甚至还躲开他们自己。<strong>害怕承认一个难以接受的真相</strong>：自己明明尽力了，却还是不能如愿&hellip;</li>
</ul>


<p>比起看清真实的自我所带来的脆弱和无地自容，<code>拖延这个借口</code>或许更容易承受。害怕失败的人有一套自己的假设：<code>自我价值感=能力=表现</code>。这个等式强迫你用每一次的表现来衡量自己的价值。每一次拖延，你可能会想：如果我付出所有的努力，而结果还不够好的话，那我无法承受这样的结局。<strong>拖延让这一次的表现不再等同于自身的能力</strong>，因为其间缺少了完整的努力——自我价值感与自己表现之间的等同关系就难以维持了（潜台词是，如果我尽力的话，我一定能做的更好）。拖延变成了一种依赖性很强的安慰剂：每一次的拖延，都不会逼着自己去面对那些尴尬、难受的场面。让自己慢慢相信潜在的能力是无限的，是要远远大于其表现的。</p>

<h3>完美主义也是凶手</h3>

<p>为了追求完美，你通常需要做很多“准备工作”，导致事情进展缓慢。
也许，你并没有意识到自己是完美主义者。反而常常会觉得，事情被弄的一团糟，怎么会是完美主义者呢？其实<strong>完美主义者可以划分为两大类：适应型和适应不良型</strong>。这两种完美主义者都对自己的要求都很高，不同的是，适应型完美主义者通常能够如愿以偿，而适应不良型则在自己的要求和对自己表现的之间存在着一些矛盾：更容易自责，也更容易感到消沉。无疑，<strong>追求完美就像追逐地平线一样</strong>：你一直往前赶，但你从来都不能真正抵达想要的位置。</p>

<p>对于完美主义者来说，<strong>放弃完美主义是一件艰巨的任务</strong>，即使他自己清晰的认识到很多追求完美的想法是不现实的。除此之外，他们还<strong>很难接受</strong>另外一个事实：<code>你现在不是，从来不是，将来也不可能是完美的</code>。</p>

<p>（其实，“感觉不适”是拖延的一个绝好理由，只有自己舒舒服服的时候才愿意采取行动——这其实是完美主义的一个翻版。）</p>

<h3>对未知的恐惧</h3>

<p>你有没有和我一样，凡是喜欢做最坏的打算？对于未知的恐惧，使得我们选择用拖延来掩饰自己的弱点，不让外界知道自己的需要和依赖。以至于每次恐惧都让我们迟迟不肯卖出第一步。这一点不细说，说多了都是泪啊。</p>

<h3>对自我掌控感的执着</h3>

<p>这一点尤其体现在被人指使去做一些自己不太情愿的事情。下面这两句，很可能在你的脑袋里出现过：“这项任务真是荒谬！”“我干嘛要按照她的意思来做？”</p>

<p>在这样的背景下，<code>拖延很可能成为你的一种心理平衡的工具</code>。它增强了你的自由感，让你自己认为并不是一个“奴隶”。因为此时此刻，你正在按自己的想法在做。(类似的情况，是体验一种报复的快感)</p>

<h3>Change We Need!</h3>

<p>从上面的分析里我们不能难看到，想要改正拖延这个顽疾，就必须得面对上述的各种恐惧、放弃曾经的各种执着，而随着岁月的积淀，这些早已形成习惯，挥之不去。</p>

<p>所以，与其和他们来硬的，不如首先<strong>接受自己的缺陷、伤痛还有伤疤</strong>。接下来呢？接下来就得看造化了，老老实实的开始呗。开始时，可能需要将目标分解成现实、具体、可行的小目标，这样的分解是可以递归进行的，直到最细小的任务出现&mdash;以至于你可以轻松的迈出第一步了。</p>
]]></content>
  </entry>
  
</feed>
