
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>mingbo</title>
	<meta name="author" content="邵明博">

	
	<meta name="description" content="Service 作为一个“看不见”的android 组件，天然的就应该为Android 程序去处理那些费事费力的苦活。但即使这样，作为四大组件之一的它依然运行在主线程上。也就是说，那些理所当然的“负担”如果直接运行在Service 上必然会影响程序的UI 性能。因此， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="mingbo" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">mingbo</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/soulsaunter">帝傲狮</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/soulsaunter">帝傲狮</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:mingbo.de">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:mingbo.de">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/11/04/services-note/">
		
			Service 心经</a>
	</h2>
	<div class="entry-content">
		<p>Service 作为一个“看不见”的android 组件，天然的就应该为Android 程序去处理那些费事费力的苦活。但即使这样，作为四大组件之一的它依然运行在主线程上。也就是说，那些理所当然的“负担”如果<strong>直接运行在Service 上必然会影响程序的UI 性能</strong>。因此，我们通常需要与之对应的后台线程来完成工作。</p>

<p>与其他组件一样，要想Service 正常运行，就必须在<code>AndroidManifest.xml</code> 中对其进行声明。如果Service 作为一个开放组件（允许外部程序调用），则还需要设置Intent Filter 来支持隐式调用；反之，如果它只在程序内运行，则可省去Filter 设置，更妥当的做法是将<code>export</code>属性设置为false。</p>

<p>总的来说，Service 有两种形式：<strong>命令启动类(Started)</strong> 与 <strong>绑定类(Bound)</strong>。两种形式之间并不总是非此既彼的关系，同一个应用的同一个Service 可以同时满足这两种形式，而这一点完全取决于应用逻辑。</p>

<h2>命令启动类（started）的Service</h2>

<ul>
<li>一旦被启动，如果没有其他组件调用<code>stopService()</code>而且自己也没有调用<code>stopSelf(int)</code>，那么它将会一直运行下去（除非系统内存吃紧）</li>
<li><code>onStartCommand()</code>有三类返回值，分别代表Service 在执行完该函数之后，如遭遇系统Kill 的不同策略：

<ol>
<li><code>START_NOT_STICKY</code>，除非有新的命令，不然不会重新构建Service</li>
<li><code>START_STICKY</code>，不死Service。如果系统资源允许，会重新构建Service并调用<code>startCommand()</code>，但并不会重新传递最后一次发过来的intent。（适用于不care 命令，而care 启没启动的操作，比如恢复音乐播放）</li>
<li><code>START_REDELIVER_INTENT</code>, 对intent 负责到底。在系统资源允许的情况下，重新构建service并将最后一次发送的intent 通过参数传递给<code>startCommand()</code>。（适用于care 命令，比如恢复下载某个文件）</li>
</ol>
</li>
<li>和绑定类服务不同，如果希望得到交互结果，则必须使用Broardcast传递</li>
<li><code>startCommand()</code> 会有并发的情况，但<code>stopService()</code> 只会执行一次。所以在具体应用场景中，我们需要考虑命令Service们能不能、该不该被中途停止。如果得到的答案是否定的，那么我们应该尝试使用<code>stopSelf(int)</code>来管理service，其参数为希望停止的service ID。</li>
</ul>


<h2>简化的命令服务IntentServie</h2>

<p>如果你不希望Service 处理并发请求，那么IntentService 是不二的选择。之所以这么说，是你几乎只需要三步就可以实现一个为你完成后台操作的单线程服务：1，继承IntetnService；2，覆盖<code>onHandleIntent()</code>；3，在构造函数中初始化父类。那么IntentService 会帮你做到：
&ndash;   创建一个后台线程
&ndash;   创建一个消息队列来执行任务
&ndash;   当没有任务的时候自动停止</p>

<p>如果希望自己覆盖某些Service 的方法，<strong>那么一定要记得调用super</strong>，否则会导致一些意想不到的结果出现。</p>

<h2>绑定类(Bound)服务</h2>

<ul>
<li><code>IBinder</code> 表示客户端与服务端交互的接口</li>
<li>三种提供Binder 接口的方法：

<ol>
<li>直接继承Binder 类，提供API 给客户端调用。这些API 既可以由Binder 子类来实现，也可以通过API 返回该服务或其他服务的实例，由服务本身提供的方法去完成调用；<strong>这种方法适用与私有服务</strong>。</li>
<li>使用Messenger返回binder。该方法的本质是AIDL，提供了一种线程安全的跨进程通讯方案。<strong>这种方法适用于服务与调用组件不在同一个进程的情况</strong>。详见<code>参考代码</code></li>
<li>如果服务不但跨进程，而且还希望处理并发请求，则应该使用<code>AIDL</code>来实现</li>
</ol>
</li>
<li>多个客户端可以绑定同一个服务，但<code>onBind()</code> 只会在第一个客户端绑定的时候被调用。之后绑定的客户端虽然会获得同样的binder，但已经不会再调用<code>onBind()</code>了</li>
<li>四大组件中除了<code>Broardcast Receiver</code>之外都可以绑定服务</li>
<li><code>onServiceDisconnected()</code>只会在服务崩溃的时候调用，<strong>而并不会在unbind 的时候被调用</strong></li>
<li>bind 应与unbind 成对出现，服务与其绑定的客户端组件共存亡。如果交互工作完全结束的话，可以尽早的结束绑定，而不一定要等到组件消亡(比如某浪sso 接口那样)</li>
<li>bind 与unbind 不应该出现在<code>onResume()</code> 以及<code>onPause()</code>里，这样会使得服务的绑定与解绑操作过于频繁</li>
<li>绑定类服务又恰巧被调用了<code>startService()</code>，则只有同时满足以下条件，服务才会终止：1，没有客户端组件绑定该服务；2，服务调用了<code>stopService()</code> 或者<code>stopSelf(int)</code></li>
<li>如下图所示，只有当<code>unBind()</code>返回true 的时候，下次绑定的时候，系统才会调用<code>onRebind()</code>，否则还会继续调用<code>onBind()</code></li>
<li>所有对象均为跨进程引用计数</li>
<li>如果服务连接丢失的话，容易引发<code>DeadObjectException</code></li>
</ul>


<p><img src="/images/20131104/service_binding_tree_lifecycle.png" alt="服务的生命周期" /></p>

<h2>前台服务</h2>

<ul>
<li>前台服务能够极大的提升不被杀掉的概率</li>
<li>前台服务必须有与之对应<strong>ON-GONING</strong>通知显示</li>
<li><code>stopForeground()</code>并不会停止服务；而停止服务后，通知自然消亡</li>
</ul>


<h2>AIDL</h2>

<ul>
<li>Stub 继承自Binder 还实现了aidl 中的接口，除此之外还提供类似<code>asInterface(IBinder)</code>的辅助方法</li>
<li>AIDL 接口调用是直接方法调用，不应该想当然的认为它们在哪个线程中执行。如果是本地进程调用，那么接口会和调用者使用同一个线程执行；如果是远程调用，会由服务所在的进程的线程池派发一个线程来执行；如果使用oneway修饰，在远程调用中是非阻塞的，而在本地调用中依然是同步的。</li>
<li>AIDL 支持java 的基础类型、<code>String</code>、<code>Charsequence</code>、<code>List</code>、<code>Map</code>，除此之外的类型，都需要实现Parcebal接口，且必须使用import来声明，即使它们在同一个包</li>
<li>调用不保证会执行，所以从一开始设计的时候就应该考虑线程安全</li>
<li>为了避免ANR，应该将调用转移到单独的线程中执行</li>
<li>抛出的异常不会被调用者捕获（跨进程异常是不可取的）</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/guide/components/services.html">Services</a></li>
<li><a href="https://developer.android.com/guide/components/bound-services.html">Bound Services</a></li>
<li><a href="https://developer.android.com/guide/components/aidl.html">AIDL</a></li>
</ul>


<h2>参考代码</h2>

<ul>
<li><a href="https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/MessengerService.java">MessengerService.java</a></li>
<li><a href="https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/MessengerServiceActivities.java">MessengerServiceActivities.java</a></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-11-04T15:21:00+08:00" pubdate data-updated="true">Nov 4<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/androidbi-ji/'>android笔记</a>


</div>
	
	
          <div class="comments"><a href="/blog/2013/11/04/services-note/#comments">Comments</a></div> 
         
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/11/03/activity-note/">
		
			Activity 心经</a>
	</h2>
	<div class="entry-content">
		<p>Android 四大组件中，Activty 最为常见。这里对Activity 的相关知识进行梳理，以供日后查阅。</p>

<h2>生命周期</h2>

<p><img src="/images/20131103/basic-lifecycle.png" alt="生命周期" /></p>

<ul>
<li>六种状态构成了生命周期金字塔</li>
<li>位于顶端的Resumed 状态有着与用户交互的特权</li>
<li>金字塔的第二层对于用户来说可视或部分可视</li>
<li>金字塔的第三层虽然存在于系统内存，但对于用户来说不可视</li>
<li>从箭头的指向来看，<strong>Resumed 与Paused 之间的转换最为活跃</strong>，为了保证UI流畅，这里应尽可能的放一些轻巧的代码</li>
<li>从Activity 对象的角度来讲，只有<strong>三种状态持续存在</strong>：Resumed，Paused，Stopped</li>
<li>Activity 的Paused 状态对于自身而言是被前台的Activity(或窗口）遮挡了一部分，对于用户来讲这个Activity 只有部分可见。<strong>在这种状态下，Activity 对象依然停留在内存里，也同时被windows manager 引用着</strong>；Activity 的Stopped状态与Paused 状态类似，<strong>除了</strong>更彻底的不可见<strong>之外</strong>，此时此刻这个Activity已经不被windows manager 引用了</li>
<li>当Activity 的Paused 或Stopped状态遭遇系统内存吃紧：系统要么温柔的调用<code>finish()</code> 逐个清理Activity，要么粗暴的结束掉该对象所在的进程</li>
</ul>


<h2>资源管理</h2>

<ul>
<li>鉴于<strong>内存吃紧</strong>的不可预见，我们应该在<code>onStop()</code>中释放掉那些容易造成内存泄漏的资源</li>
<li>关于<code>onPause()</code>方法更具体的建议

<pre><code>1.  停止动画等消耗CPU 的操作
2.  注销广播监听器、传感器监听器等影响电池寿命的资源
3.  仅当用户需要的情况下，提交未保存的状态。为了保证界面的平滑切换，应避免在这里调用CPU-Intensive 的操作（如，写数据库），而应将其移至之后的stop方法中
</code></pre></li>
<li> <code>onSaveInstanceState()</code>默认的会保存Activity 的视图结构，如Checkbox 是否被选中，Edittext 中的编辑文字，但前提是为每个控件都配备有一个独特的ID</li>
<li> 当且仅当有数据需要恢复的时候，<code>onRestoreInstanceState()</code>才被系统调用，且一般在<code>onStart()</code>之后</li>
<li> 可以使用<code>finish()</code>以及<code>finishActivity(int requestCode)</code>来关闭Activity，但除非你确定必须这么做，<strong>不然最好将这项工作交由系统来完成</strong></li>
<li> 一般情况下，如果一个应用退到后台超过30分钟，系统会清理掉该堆栈中的acitivties。但如果<code>android:alwaysRetainTaskState</code>属性被设置为true，用户重返应用的时候总会获得上次Activity的状态。这一点对于浏览器应用相当有用</li>
<li> 如果属性<code>android:noHistory</code>被设置为true，那么当用户从这个activity 离开的时候，就会自动调用<code>finish()</code>。因此，无法从任务堆栈中找回该activity 的历史轨迹了</li>
<li> 一般来讲，<code>onDestroy()</code> 的执行应该在<code>onPause()</code>或者<code>onStop()</code>之后。但如果，你在<code>onCreate()</code>中直接调用<code>finish()</code>，则系统会直接跳过他们调用<code>onDestroy()</code>的</li>
</ul>


<h2>运行模式</h2>

<ul>
<li>Task 是由一组为了完成某项工作的Activities 组成，它们<strong>不受</strong>进程或应用的约束，体现的是Activity 之间<strong>相互调用和执行</strong>的关系</li>
<li>Activity 的运行模式有四种:standard，singleTop，singleTask，singleInstance。除了Standard 之外的三种模式对于activity均有不同程度的复用</li>
<li>standard 与singleTop 类似，在程序运行的过程中，这两种模式的activity 会有多个实例出现在一个或多个Task 中的任意位置。但二者之间有着细微的差别：singleTop 模式下的activty 如果在目标task 的顶部，对于新收到的intent会使用<code>onNewIntent()</code>回调来响应；其他情况下和standard 模式一样，对于每一个新收到的intent 都对应一个新的实例。</li>
<li>singleTask 与singleInstance 类似，都只能出现在一个task stack 内，且始终呆在stack 的根部，对于整个设备来说它们只有一个实例。除此之外，它们都使用<code>onNewIntent()</code> 来响应创建后收到的intent。但两者之间有着细微的差别：singleTask 允许引入新的activity 来组建task，而singleInstance 永远自成一派。很显然，singleInstance适合内存消耗较多的界面，如播放器、浏览器等。</li>
</ul>


<h2>其他</h2>

<ul>
<li>如果项目中没有一个Activity 被设置为<code>MAIN action</code> 或者<code>LAUNCHER category</code>，那么桌面就不会显示相应的图标</li>
<li>程序运行过程中，如遇到配置变动，则会引起activity 重启，这是系统自动适配的行为。</li>
<li>重启后，其数据需要得到重新填充。如果数据量较小，则可以依赖<code>onSaveInstanceState()</code>以及<code>onRestoreInstanceState()</code>这两个回调接口；反之，则需要特殊对待：要么规避系统的重启行为，自己来做适配工作；要么在配置变更的时候通过接口<code>onRetainNonConfigurationInstance()</code>来保存数据对象，待到重启之后使用<code>getLastNonConfigurationInstance()</code>来恢复相关数据</li>
</ul>


<hr />

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/starting.html">Starting an Activity</a></li>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/pausing.html">Pausing and Resuming an Activity</a></li>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/stopping.html">Stopping and Restarting an Activity</a></li>
<li><a href="https://developer.android.com/training/basics/activity-lifecycle/recreating.html">Recreating an Activity</a></li>
<li><a href="https://developer.android.com/guide/components/activities.html">Activities</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/activity-element.html">android:launchMode</a></li>
<li><a href="https://developer.android.com/guide/topics/resources/runtime-changes.html">Handling Runtime Changes</a></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-11-03T11:33:00+08:00" pubdate data-updated="true">Nov 3<span>rd</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/androidbi-ji/'>android笔记</a>


</div>
	
	
          <div class="comments"><a href="/blog/2013/11/03/activity-note/#comments">Comments</a></div> 
         
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/04/14/comment-is-cheap/">
		
			廉价的吐槽</a>
	</h2>
	<div class="entry-content">
		<p>这几年，你有没有发现“赞美”变成了一件奢侈的事情？尤其当你面对一群挑剔的听众，你的赞美往往会被人扭曲：“你拿了人家什么好处，这样帮他说话？”、“推销？你被洗脑了吧！”、“这你都没见过？有什么好大惊小怪的。”…诸如此类。不晓得从什么时候开始，开口赞美，也变得越来越有压力了。</p>

<p>赞美的起点似乎总比被赞美的事物要低，反而吐槽更容易让你居高临下，优越感一览无遗。不管人家说什么，你跟着去赞美，容易被人说成是拍马，而吐槽的言行至少不会显得你太低端（哈哈，说这是批判精神）。这种不用思考的“安全反应”，使得越来越多的人，习惯了吐槽。当跟风赞美变成弱智、“五毛”之后，跟风吐槽就显得有节操，有品位了。任何事情，你都可以表现得不屑一顾，“安全的”凌驾于其之上。只是，这种廉价的破烂习惯，让我们的社会关系变得越来越冷漠了。</p>

<p>其实，生活中并不缺乏温情的画面，讲一个刚刚发生的故事。昨天晚上，我习惯性的去了趟沃尔玛。轮到我结账的时候，为了不让后面排队的人等太久，我手忙脚乱的把货品往买来的2个袋子里塞。收银员打断了我的动作，说：你这些速冻食品压在最底下，回家的时候肯定就烂掉了。我愣了一下，结果，她很自然的接手了剩下来的操作。只用了一个袋子，就将所有货品麻利的装了进去，还照顾到了各种货品的运输属性（易碎性、温度、空间等），合理的安排了他们在装袋时的位置。很快的，我缓过神来，没有说话，但竖起了大拇指。</p>

<p>同样是排队结账，吐槽就显得太过廉价了。你永远可以调侃中国人多，甚至责怪超市收银出口太少，但绝大多数的情况下，你都无法避免排队等候。而这种廉价的吐槽行为，只会让自己愤怒，说不定还会影响他人，人与人之间就在消费吐槽时，变得淡了下来。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-04-14T19:44:00+08:00" pubdate data-updated="true">Apr 14<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/hu-si-luan-xiang/'>胡思乱想</a>


</div>
	
	
          <div class="comments"><a href="/blog/2013/04/14/comment-is-cheap/#comments">Comments</a></div> 
         
</div>
</article>

<nav id="pagenavi">
    
        <a href="/blog/page/2/" class="prev">Prev</a>
    
    
        <a href="/blog/page/4/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    邵明博

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->




	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-37619750-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>